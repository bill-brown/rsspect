package com.colorful.rss;

import java.io.File;
import java.io.FileInputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.StringWriter;
import java.io.Writer;
import java.lang.reflect.Constructor;
import java.util.Comparator;
import java.util.Date;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Properties;
import java.util.SortedMap;
import java.util.TreeMap;

import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLOutputFactory;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import javax.xml.stream.XMLStreamWriter;

/**
 * This class reads and writes RSS documents to and from xml files, objects or
 * Strings. It contains all of the factory methods for building immutable copies
 * of the object elements.
 * 
 * @author Bill Brown
 * 
 */
public class RSSDoc {

	/**
	 * the default document encoding of "UTF-8"
	 */
	public static String encoding = "UTF-8";

	/**
	 * the default XML version of "1.0"
	 */
	public static String xml_version = "1.0";

	private static String libUri;
	private static String libVersion;
	static {
		try {
			Properties props = new Properties();
			props.load(RSSDoc.class.getResourceAsStream("/rsspect.properties"));
			libUri = props.getProperty("uri");
			libVersion = props.getProperty("version");
		} catch (Exception e) {
			// should not happen.
			e.printStackTrace();
		}
	}

	/**
	 * @return the RSSpect library version in the form of a generator element.
	 *         This element is output for all feeds that are generated by
	 *         RSSpect.
	 */
	public static Generator getRSSpectVersion() {
		return RSSDoc.buildGenerator(libUri + " v" + libVersion);
	}

	/**
	 * Comparator for sorting feed entries in descending order
	 */
	public static final Comparator<String> SORT_DESC = new Comparator<String>() {
		public int compare(String key1, String key2) {
			return key2.compareTo(key1);
		}
	};

	/**
	 * 
	 * @param output
	 *            the target output for the rss document.
	 * @param rss
	 *            the rss object containing the content of the feed
	 * @param encoding
	 *            the file encoding (default is UTF-8)
	 * @param version
	 *            the xml version (default is 1.0)
	 * @throws Exception
	 *             thrown if the feed cannot be written to the output
	 */
	public static void writeFeedDoc(OutputStream output, RSS rss,
			String encoding, String version) throws Exception {
		writeFeedDoc(XMLOutputFactory.newInstance().createXMLStreamWriter(
				output, encoding), rss, encoding, version);
	}

	/**
	 * 
	 * @param output
	 *            the target output for the document.
	 * @param rss
	 *            the rss object containing the content of the feed
	 * @param encoding
	 *            the file encoding (default is UTF-8)
	 * @param version
	 *            the xml version (default is 1.0)
	 * @throws Exception
	 *             thrown if the feed cannot be written to the output
	 */
	public static void writeFeedDoc(Writer output, RSS rss, String encoding,
			String version) throws Exception {
		writeFeedDoc(XMLOutputFactory.newInstance().createXMLStreamWriter(
				output), rss, encoding, version);
	}

	/**
	 * For example: to pass the TXW
	 * com.sun.xml.txw2.output.IndentingXMLStreamWriter or the stax-utils
	 * javanet.staxutils.IndentingXMLStreamWriter for indented printing do this:
	 * 
	 * <pre>
	 * XmlStreamWriter writer = new IndentingXMLStreamWriter(XMLOutputFactory
	 * 		.newInstance().createXMLStreamWriter(
	 * 				new FileOutputStream(outputFilePath), encoding));
	 * RSSDoc.writeFeedDoc(writer, myFeed, null, null);
	 * </pre>
	 * 
	 * @param output
	 *            the target output for the feed.
	 * @param rss
	 *            the rss object containing the content of the feed
	 * @param encoding
	 *            the file encoding (default is UTF-8)
	 * @param version
	 *            the xml version (default is 1.0)
	 * @throws Exception
	 *             thrown if the feed cannot be written to the output
	 */
	public static void writeFeedDoc(XMLStreamWriter output, RSS rss,
			String encoding, String version) throws Exception {

		try {
			writeFeedOutput(rss, output, encoding, version);
		} catch (Exception e) {
			throw new Exception("error creating the feed document.", e);
		}
	}

	/**
	 * This method reads in a Feed element and returns the contents as an atom
	 * feed string with formatting specified by the fully qualified
	 * XMLStreamWriter class name (uses reflection internally). For example you
	 * can pass the TXW com.sun.xml.txw2.output.IndentingXMLStreamWriter or the
	 * stax-utils javanet.staxutils.IndentingXMLStreamWriter for indented
	 * printing. It will fall back to
	 * 
	 * <pre>
	 * readFeedToString(Feed)
	 * </pre>
	 * 
	 * if the XMLStreamWriter class cannot be found in the classpath.
	 * 
	 * @param rss
	 *            the rss object to be converted to an atom document string.
	 * @param xmlStreamWriter
	 *            the fully qualified XMLStreamWriter class name.
	 * @return an atom feed document string.
	 * @throws Exception
	 *             thrown if the feed cannot be returned as a String
	 */
	public static String readFeedToString(RSS rss, String xmlStreamWriter)
			throws Exception {

		StringWriter theString = new StringWriter();
		try {
			Class<?> cls = Class.forName(xmlStreamWriter);
			Constructor<?> ct = cls
					.getConstructor(new Class[] { XMLStreamWriter.class });
			Object arglist[] = new Object[] { XMLOutputFactory.newInstance()
					.createXMLStreamWriter(theString) };
			XMLStreamWriter writer = (XMLStreamWriter) ct.newInstance(arglist);

			writeFeedOutput(rss, writer, encoding, xml_version);

		} catch (Exception e) {
			return readFeedToString(rss);
		}
		return theString.toString();
	}

	/**
	 * This method reads in a Feed bean and returns the contents as an atom feed
	 * string.
	 * 
	 * @param rss
	 *            the rss object to be converted to an atom string.
	 * @return an atom feed document string.
	 * @throws Exception
	 *             thrown if the feed cannot be returned as a String
	 */
	public static String readFeedToString(RSS rss) throws Exception {

		StringWriter theString = new StringWriter();
		try {
			XMLOutputFactory outputFactory = XMLOutputFactory.newInstance();
			XMLStreamWriter writer = outputFactory
					.createXMLStreamWriter(theString);

			writeFeedOutput(rss, writer, encoding, xml_version);

		} catch (Exception e) {
			throw new Exception("error creating xml file.", e);
		}
		return theString.toString();
	}

	/**
	 * This method reads an xml string into a Feed element.
	 * 
	 * @param xmlString
	 *            the xml string to be transformed into a RSS element.
	 * @return the RSS element
	 * @throws Exception
	 *             if the string cannot be parsed into a RSS element.
	 */
	public static RSS readRSSToBean(String xmlString) throws Exception {
		XMLInputFactory inputFactory = XMLInputFactory.newInstance();
		XMLStreamReader reader = inputFactory
				.createXMLStreamReader(new java.io.StringReader(xmlString));
		return new RSSReader().readRSS(reader);
	}

	/**
	 * This method reads an xml File object into a Feed element.
	 * 
	 * @param file
	 *            the file object representing an rss feed.
	 * @return the RSS element.
	 * @throws Exception
	 *             if the file cannot be parsed into a RSS element.
	 */
	public static RSS readFeedToBean(File file) throws Exception {
		XMLInputFactory inputFactory = XMLInputFactory.newInstance();
		XMLStreamReader reader = inputFactory
				.createXMLStreamReader(new FileInputStream(file));
		return new RSSReader().readRSS(reader);
	}

	/**
	 * This method reads an rss file from a URL into a Feed element.
	 * 
	 * @param url
	 *            the Internet network location of an rss file.
	 * @return the RSS element.
	 * @throws Exception
	 *             if the URL cannot be parsed into a RSS element.
	 */
	public static RSS readRSSToBean(java.net.URL url) throws Exception {
		return readFeedToBean(url.openStream());
	}

	/**
	 * This method reads an rss file from an input stream into a RSS element.
	 * 
	 * @param inputStream
	 *            the input stream containing an rss file.
	 * @return the RSS element.
	 * @throws Exception
	 *             if the URL cannot be parsed into a RSS element.
	 */
	public static RSS readFeedToBean(InputStream inputStream) throws Exception {
		XMLInputFactory inputFactory = XMLInputFactory.newInstance();
		XMLStreamReader reader = inputFactory
				.createXMLStreamReader(inputStream);
		return new RSSReader().readRSS(reader);
	}

	/**
	 * 
	 * @param channel
	 *            the unique channel element (required)
	 * @param attributes
	 *            additional attributes (optional)
	 * @param extensions
	 *            additional extensions (optional)
	 * @return an immutable RSS object.
	 * @throws RSSpectException.
	 */
	public static RSS buildRSS(Channel channel, List<Attribute> attributes,
			List<Extension> extensions) throws RSSpectException {
		return new RSS(channel, attributes, extensions);
	}

	/**
	 * 
	 * @param name
	 *            the attribute name.
	 * @param value
	 *            the attribute value.
	 * @return an immutable Attribute object.
	 */
	public static Attribute buildAttribute(String name, String value) {
		return new Attribute(name, value);
	}

	/**
	 * 
	 * @param author
	 *            the author element. (required)
	 * @return an immutable Author object.
	 */
	public static Author buildAuthor(String author) {
		return new Author(author);
	}

	/**
	 * @param domain
	 *            the domain attribute
	 * @param category
	 *            the category text
	 * @return an immutable Category object.
	 */
	public static Category buildCategory(Attribute domain, String category) {
		return new Category(domain, category);
	}

	/**
	 * 
	 * @param title
	 * @param link
	 * @param description
	 * @param language
	 * @param copyright
	 * @param managingEditor
	 * @param webMaster
	 * @param pubDate
	 * @param lastBuildDate
	 * @param categories
	 * @param generator
	 * @param docs
	 * @param cloud
	 * @param ttl
	 * @param image
	 * @param rating
	 * @param textInput
	 * @param skipHours
	 * @param skipDays
	 * @param items
	 * @param extensions
	 * @return an immutable Channel object.
	 * @throws RSSpectException
	 */
	public static Channel buildChannel(Title title, Link link,
			Description description, Language language, Copyright copyright,
			ManagingEditor managingEditor, WebMaster webMaster,
			PubDate pubDate, LastBuildDate lastBuildDate,
			List<Category> categories, Generator generator, Docs docs,
			Cloud cloud, TTL ttl, Image image, Rating rating,
			TextInput textInput, SkipHours skipHours, SkipDays skipDays,
			List<Item> items, List<Extension> extensions)
			throws RSSpectException {
		return new Channel(title, link, description, language, copyright,
				managingEditor, webMaster, pubDate, lastBuildDate, categories,
				generator, docs, cloud, ttl, image, rating, textInput,
				skipHours, skipDays, items, extensions);
	}

	/**
	 * 
	 * @param cloud
	 * @return an immutable Cloud object.
	 */
	public static Cloud buildCloud(String cloud) {
		return new Cloud(cloud);
	}

	/**
	 * 
	 * @param comments
	 * @return an immutable Comments object.
	 */
	public static Comments buildComments(String comments) {
		return new Comments(comments);
	}

	/**
	 * 
	 * @param copyright
	 * @return an immutable Copyright object.
	 */
	public static Copyright buildCopyright(String copyright) {
		return new Copyright(copyright);
	}

	/**
	 * 
	 * @param description
	 * @return an immutable Description object.
	 */
	public static Description buildDescription(String description) {
		return new Description(description);
	}

	/**
	 * 
	 * @param docs
	 * @return an immutable Docs object.
	 */
	public static Docs buildDocs(String docs) {
		return new Docs(docs);
	}

	/**
	 * 
	 * @param attributes
	 *            should contain url, length and type
	 * @param enclosure
	 * @return an immutable Enclosure object.
	 * @throws RSSpectException
	 */
	public static Enclosure buildEnclosure(List<Attribute> attributes,
			String enclosure) throws RSSpectException {
		return new Enclosure(attributes, enclosure);
	}

	/**
	 * 
	 * @param elementName
	 *            the name of the extension element.
	 * @param attributes
	 *            additional attributes.
	 * @param content
	 *            the content of the extension element.
	 * @return an immutable Extension object.
	 */
	public static Extension buildExtension(String elementName,
			List<Attribute> attributes, String content) {
		return new Extension(elementName, attributes, content);
	}

	/**
	 * @param text
	 *            the text content.
	 * @return an immutable Generator object.
	 */
	public static Generator buildGenerator(String text) {
		return new Generator(text);
	}

	/**
	 * 
	 * @param isPermaLink
	 * @param guid
	 * @return an immutable GUID object.
	 */
	public static GUID buildGUID(Attribute isPermaLink, String guid) {
		return new GUID(isPermaLink, guid);
	}

	/**
	 * 
	 * @param height
	 *            should be a number 400 or less
	 * @return an immutable Height object.
	 * @throws RSSpectException
	 */
	public static Height buildHeight(String height) throws RSSpectException {
		return new Height(height);
	}

	/**
	 * 
	 * @param url
	 * @param title
	 * @param link
	 * @param width
	 * @param height
	 * @param description
	 * @return an immutable Image object.
	 * @throws RSSpectException
	 */
	public static Image buildImage(URL url, Title title, Link link,
			Width width, Height height, Description description)
			throws RSSpectException {
		return new Image(url, title, link, width, height, description);
	}

	/**
	 * 
	 * @param title
	 * @param link
	 * @param description
	 * @param author
	 * @param categories
	 * @param comments
	 * @param enclosure
	 * @param guid
	 * @param pubDate
	 * @param source
	 * @param extensions
	 * @return an immutable Item object.
	 * @throws RSSpectException
	 */
	public static Item buildItem(Title title, Link link,
			Description description, Author author, List<Category> categories,
			Comments comments, Enclosure enclosure, GUID guid, PubDate pubDate,
			Source source, List<Extension> extensions) throws RSSpectException {
		return new Item(title, link, description, author, categories, comments,
				enclosure, guid, pubDate, source, extensions);
	}

	/**
	 * 
	 * @param language
	 * @return an immutable Language object.
	 */
	public static Language buildLanguage(String language) {
		return new Language(language);
	}

	/**
	 * 
	 * @param lastBuildDate
	 * @return an immutable LastBuildDate object.
	 */
	public static LastBuildDate buildLastBuildDate(Date lastBuildDate) {
		return new LastBuildDate(lastBuildDate);
	}

	/**
	 * 
	 * @param link
	 * @return an immutable Link object.
	 * @throws RSSpectException
	 */
	public static Link buildLink(String link) throws RSSpectException {
		return new Link(link);
	}

	/**
	 * 
	 * @param managingEditor
	 * @return an immutable ManagingEditor object.
	 */
	public static ManagingEditor buildManagingEditor(String managingEditor) {
		return new ManagingEditor(managingEditor);
	}

	/**
	 * 
	 * @param name
	 * @return an immutable Name object.
	 */
	public static Name buildName(String name) {
		return new Name(name);
	}

	/**
	 * 
	 * @param pubDate
	 * @return an immutable PubDate object.
	 */
	public static PubDate buildPubDate(Date pubDate) {
		return new PubDate(pubDate);
	}

	/**
	 * 
	 * @param rating
	 * @return an immutable Rating object.
	 */
	public static Rating buildRating(String rating) {
		return new Rating(rating);
	}

	/**
	 * 
	 * @param skipDays
	 * @return an immutable SkipDays object.
	 */
	public static SkipDays buildSkipDays(String skipDays) {
		return new SkipDays(skipDays);
	}

	/**
	 * 
	 * @param skipHours
	 * @return an immutable SkipHours object.
	 */
	public static SkipHours buildSkipHours(String skipHours) {
		return new SkipHours(skipHours);
	}

	/**
	 * 
	 * @param source
	 * @param url
	 * @return an immutable Source object.
	 * @throws RSSpectException
	 */
	public static Source buildSource(String source, Attribute url)
			throws RSSpectException {
		return new Source(source, url);
	}

	/**
	 * 
	 * @param title
	 * @param description
	 * @param name
	 * @param link
	 * @return an immutable TextInput object.
	 * @throws RSSpectException
	 */
	public static TextInput buildTextInput(Title title,
			Description description, Name name, Link link)
			throws RSSpectException {
		return new TextInput(title, description, name, link);
	}

	/**
	 * 
	 * @param title
	 * @return an immutable Title object.
	 */
	public static Title buildTitle(String title) {
		return new Title(title);
	}

	/**
	 * 
	 * @param ttl
	 * @return an immutable TTL object.
	 */
	public static TTL buildTTL(String ttl) {
		return new TTL(ttl);
	}

	/**
	 * 
	 * @param url
	 * @return an immutable URL object.
	 * @throws RSSpectException
	 */
	public static URL buildURL(String url) throws RSSpectException {
		return new URL(url);
	}

	/**
	 * 
	 * @param webMaster
	 * @return an immutable WebMaster object.
	 */
	public static WebMaster buildWebMaster(String webMaster) {
		return new WebMaster(webMaster);
	}

	/**
	 * 
	 * @param width
	 * @return an immutable Width object.
	 * @throws RSSpectException
	 */
	public static Width buildWidth(String width) throws RSSpectException {
		return new Width(width);
	}

	// used to write feed output for several feed writing methods.
	private static void writeFeedOutput(RSS rss, XMLStreamWriter writer,
			String encoding, String version) throws XMLStreamException,
			Exception {

		// write the xml header.
		writer.writeStartDocument(encoding, version);
		new RSSWriter().writeRSS(writer, rss);
		writer.flush();
		writer.close();
	}

	// checks for and returns the Attribute from the String attribute (argument)
	// in the list of attributes (argument)
	static Attribute getAttributeFromGroup(List<Attribute> attributes,
			String attributeName) {
		if (attributes != null) {
			for (Attribute current : attributes) {
				if (current.getName().equalsIgnoreCase(attributeName)) {
					return buildAttribute(current.getName(), current.getValue());
				}
			}
		}
		return null;
	}

}
