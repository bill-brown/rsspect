/**
 * Copyright (C) 2009 William R. Brown <wbrown@colorfulsoftware.com>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
package com.colorfulsoftware.rss;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.Serializable;
import java.io.StringWriter;
import java.lang.reflect.Constructor;
import java.util.List;
import java.util.Properties;

import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLOutputFactory;
import javax.xml.stream.XMLStreamReader;
import javax.xml.stream.XMLStreamWriter;

/**
 * This class reads and writes RSS documents to and from xml files, objects or
 * Strings. It contains all of the factory methods for building immutable copies
 * of the object elements.
 * 
 * 
 * @author Bill Brown
 * 
 */
public final class RSSDoc implements Serializable {

	private static final long serialVersionUID = 649162683570000798L;

	/**
	 * the default document encoding of "UTF-8"
	 */
	private String encoding = System.getProperty("file.encoding");

	/**
	 * the default XML version of "1.0"
	 */
	private String xmlVersion = "1.0";

	private String libUri;
	private String libVersion;

	private XMLInputFactory inputFactory;

	/**
	 * @throws Exception
	 *             if the rsspect.properties file cant be read.
	 * 
	 */
	public RSSDoc() throws Exception {
		Properties props = new Properties();
		props.load(RSSDoc.class.getResourceAsStream("/rsspect.properties"));
		libUri = props.getProperty("uri");
		libVersion = props.getProperty("version");

		inputFactory = XMLInputFactory.newInstance();
		// this is done to help for parsing documents that have undeclared and
		// unescaped html or xhtml entities.
		inputFactory.setProperty(
				"javax.xml.stream.isReplacingEntityReferences", Boolean.FALSE);
	}

	/**
	 * @param encoding
	 *            the xml encoding eg. UTF-8
	 * @param xmlVersion
	 *            the xml document version eg. 1.0
	 * @throws Exception
	 *             if the rsspect properties file cant be read.
	 */
	public RSSDoc(String encoding, String xmlVersion) throws Exception {
		this();
		this.encoding = encoding;
		this.xmlVersion = xmlVersion;
	}

	/**
	 * @return the RSSpect library version in the form of a generator element.
	 *         This element is output for all feeds that are generated by
	 *         RSSpect.
	 */
	public Generator getRSSpectVersion() {
		return buildGenerator(libUri + " v" + libVersion);
	}

	/**
	 * 
	 * @param output
	 *            the target output stream for the rss document.
	 * @param rss
	 *            the rss object containing the content of the feed
	 * @param encoding
	 *            the file encoding (default is UTF-8)
	 * @param version
	 *            the xml version (default is 1.0)
	 * @throws Exception
	 *             thrown if the feed cannot be written to the output
	 */
	public void writeRSSDoc(OutputStream output, RSS rss, String encoding,
			String version) throws Exception {
		writeRSSOutput(rss, XMLOutputFactory.newInstance()
				.createXMLStreamWriter(output, encoding), encoding, version);

	}

	/**
	 * 
	 * @param file
	 *            the target output file for the document.
	 * @param rss
	 *            the rss object containing the content of the feed
	 * @param encoding
	 *            the file encoding (default is UTF-8)
	 * @param version
	 *            the xml version (default is 1.0)
	 * @throws Exception
	 *             thrown if the feed cannot be written to the output
	 */
	public void writeRSSDoc(File file, RSS rss, String encoding, String version)
			throws Exception {
		writeRSSOutput(rss, XMLOutputFactory.newInstance()
				.createXMLStreamWriter(new FileOutputStream(file), encoding),
				encoding, version);
	}

	/**
	 * For example: to pass the TXW
	 * com.sun.xml.txw2.output.IndentingXMLStreamWriter or the stax-utils
	 * javanet.staxutils.IndentingXMLStreamWriter for indented printing do this:
	 * 
	 * <pre>
	 * XmlStreamWriter writer = new IndentingXMLStreamWriter(XMLOutputFactory
	 * 		.newInstance().createXMLStreamWriter(
	 * 				new FileOutputStream(outputFilePath), encoding));
	 * RSSDoc.writeFeedDoc(writer, myFeed, null, null);
	 * </pre>
	 * 
	 * @param output
	 *            the target output for the feed.
	 * @param rss
	 *            the rss object containing the content of the feed
	 * @param encoding
	 *            the file encoding (default is UTF-8)
	 * @param version
	 *            the xml version (default is 1.0)
	 * @throws Exception
	 *             thrown if the feed cannot be written to the output
	 */
	public void writeRSSDoc(XMLStreamWriter output, RSS rss, String encoding,
			String version) throws Exception {
		writeRSSOutput(rss, output, encoding, version);
	}

	/**
	 * This method reads in a Feed element and returns the contents as an rss
	 * feed string with formatting specified by the fully qualified
	 * XMLStreamWriter class name (uses reflection internally). For example you
	 * can pass the TXW com.sun.xml.txw2.output.IndentingXMLStreamWriter or the
	 * stax-utils javanet.staxutils.IndentingXMLStreamWriter for indented
	 * printing. It will fall back to
	 * 
	 * <pre>
	 * readFeedToString(Feed)
	 * </pre>
	 * 
	 * if the XMLStreamWriter class cannot be found in the classpath.
	 * 
	 * @param rss
	 *            the rss object to be converted to an rss document string.
	 * @param xmlStreamWriter
	 *            the fully qualified XMLStreamWriter class name.
	 * @return an rss feed document string.
	 * @throws Exception
	 *             thrown if the feed cannot be returned as a String
	 */
	public String readRSSToString(RSS rss, String xmlStreamWriter)
			throws Exception {
		try {
			StringWriter theString = new StringWriter();

			Class<?> cls = Class.forName(xmlStreamWriter);
			Constructor<?> ct = cls
					.getConstructor(new Class[] { XMLStreamWriter.class });
			Object arglist[] = new Object[] { XMLOutputFactory.newInstance()
					.createXMLStreamWriter(theString) };
			XMLStreamWriter writer = (XMLStreamWriter) ct.newInstance(arglist);

			writeRSSOutput(rss, writer, encoding, xmlVersion);

			return theString.toString();

			// if the xmlStreamWriter cannot be found, read with the default
		} catch (Exception e) {
			return readRSSToString(rss);
		}
	}

	/**
	 * This method reads in a Feed bean and returns the contents as an rss feed
	 * string.
	 * 
	 * @param rss
	 *            the rss object to be converted to an rss string.
	 * @return an rss feed document string.
	 * @throws Exception
	 *             thrown if the feed cannot be returned as a String
	 */
	public String readRSSToString(RSS rss) throws Exception {
		StringWriter theString = new StringWriter();

		XMLOutputFactory outputFactory = XMLOutputFactory.newInstance();
		XMLStreamWriter writer = outputFactory.createXMLStreamWriter(theString);

		writeRSSOutput(rss, writer, encoding, xmlVersion);

		return theString.toString();
	}

	/**
	 * This method reads an xml string into a Feed element.
	 * 
	 * @param xmlString
	 *            the xml string to be transformed into a RSS element.
	 * @return the RSS element
	 * @throws RSSpectException
	 *             if the string cannot be parsed into a RSS element.
	 */
	public RSS readRSSToBean(String xmlString) throws RSSpectException {
		// try to grab the encoding first:
		if (xmlString.contains("encoding=\"")) {
			String localEncoding = xmlString.substring(xmlString
					.indexOf("encoding=\"") + 10);
			localEncoding = localEncoding.substring(0, localEncoding
					.indexOf('"'));
			encoding = localEncoding;

		}
		try {
			XMLStreamReader reader = inputFactory
					.createXMLStreamReader(new ByteArrayInputStream(xmlString
							.getBytes(encoding)));
			return new RSSReader().readRSS(reader);
		} catch (RSSpectException e) {
			throw e;
		} catch (Exception e) {
			throw new RSSpectException(e.getLocalizedMessage());
		}
	}

	/**
	 * This method reads an xml File object into a Feed element.
	 * 
	 * @param file
	 *            the file object representing an rss feed.
	 * @return the RSS element.
	 * @throws RSSpectException
	 *             if the file cannot be parsed into a RSS element.
	 */
	public RSS readRSSToBean(File file) throws RSSpectException {
		try {
			XMLStreamReader reader = inputFactory
					.createXMLStreamReader(new FileInputStream(file));
			return new RSSReader().readRSS(reader);
		} catch (RSSpectException e) {
			throw e;
		} catch (Exception e) {
			throw new RSSpectException(e.getLocalizedMessage());
		}
	}

	/**
	 * This method reads an rss file from a URL into a Feed element.
	 * 
	 * @param url
	 *            the Internet network location of an rss file.
	 * @return the RSS element.
	 * @throws RSSpectException
	 *             if the URL cannot be parsed into a RSS element.
	 */
	public RSS readRSSToBean(java.net.URL url) throws RSSpectException {
		try {
			return readRSSToBean(url.openStream());
		} catch (RSSpectException e) {
			throw e;
		} catch (Exception e) {
			throw new RSSpectException(e.getLocalizedMessage());
		}

	}

	/**
	 * This method reads an rss file from an input stream into a RSS element.
	 * 
	 * @param inputStream
	 *            the input stream containing an rss file.
	 * @return the RSS element.
	 * @throws RSSpectException
	 *             if the URL cannot be parsed into a RSS element.
	 */
	public RSS readRSSToBean(InputStream inputStream) throws RSSpectException {
		try {
			XMLStreamReader reader = inputFactory
					.createXMLStreamReader(inputStream);
			return new RSSReader().readRSS(reader);
		} catch (RSSpectException e) {
			throw e;
		} catch (Exception e) {
			throw new RSSpectException(e.getLocalizedMessage());
		}
	}

	/**
	 * 
	 * @param channel
	 *            the unique channel element (required)
	 * @param attributes
	 *            additional attributes (optional)
	 * @param extensions
	 *            additional extensions (optional)
	 * @return an immutable RSS object.
	 * @throws RSSpectException
	 *             if the format of the data is not valid.
	 */
	public RSS buildRSS(Channel channel, List<Attribute> attributes,
			List<Extension> extensions) throws RSSpectException {
		return new RSS(channel, attributes, extensions);
	}

	/**
	 * 
	 * @param name
	 *            the attribute name.
	 * @param value
	 *            the attribute value.
	 * @return an immutable Attribute object.
	 * @throws RSSpectException
	 *             if the data is not valid.
	 */
	public Attribute buildAttribute(String name, String value)
			throws RSSpectException {
		return new Attribute(name, value);
	}

	/**
	 * 
	 * @param author
	 *            the author element. (required)
	 * @return an immutable Author object.
	 */
	public Author buildAuthor(String author) {
		return new Author(author);
	}

	/**
	 * @param domain
	 *            the domain attribute
	 * @param category
	 *            the category text
	 * @return an immutable Category object.
	 * @throws RSSpectException
	 *             if the format of the data is not valid.
	 */
	public Category buildCategory(Attribute domain, String category)
			throws RSSpectException {
		return new Category(domain, category);
	}

	/**
	 * 
	 * @param title
	 *            the title element.
	 * @param link
	 *            the link element.
	 * @param description
	 *            the description element.
	 * @param language
	 *            the language element.
	 * @param copyright
	 *            the copyright element.
	 * @param managingEditor
	 *            the managingEditor element.
	 * @param webMaster
	 *            the webMaster element.
	 * @param pubDate
	 *            the pubDate element.
	 * @param lastBuildDate
	 *            the lastBuildDate element.
	 * @param categories
	 *            the list of categories
	 * @param generator
	 *            the generator element.
	 * @param docs
	 *            the docs element.
	 * @param cloud
	 *            the cloud element.
	 * @param ttl
	 *            the ttl element.
	 * @param image
	 *            the image element.
	 * @param rating
	 *            the rating element.
	 * @param textInput
	 *            the textInput element.
	 * @param skipHours
	 *            the skipHours element.
	 * @param skipDays
	 *            the skipDays element.
	 * @param items
	 *            the list of items.
	 * @param extensions
	 *            the list of extensions.
	 * @return an immutable Channel object.
	 * @throws RSSpectException
	 *             if the format of the data is not valid.
	 */
	public Channel buildChannel(Title title, Link link,
			Description description, Language language, Copyright copyright,
			ManagingEditor managingEditor, WebMaster webMaster,
			PubDate pubDate, LastBuildDate lastBuildDate,
			List<Category> categories, Generator generator, Docs docs,
			Cloud cloud, TTL ttl, Image image, Rating rating,
			TextInput textInput, SkipHours skipHours, SkipDays skipDays,
			List<Extension> extensions, List<Item> items)
			throws RSSpectException {
		return new Channel(title, link, description, language, copyright,
				managingEditor, webMaster, pubDate, lastBuildDate, categories,
				generator, docs, cloud, ttl, image, rating, textInput,
				skipHours, skipDays, extensions, items);
	}

	/**
	 * 
	 * @param attributes
	 *            the list of attributes.
	 * @return an immutable Cloud object.
	 * @throws RSSpectException
	 *             if the format of the data is not valid.
	 */
	public Cloud buildCloud(List<Attribute> attributes) throws RSSpectException {
		return new Cloud(attributes);
	}

	/**
	 * 
	 * @param comments
	 *            the comments.
	 * @return an immutable Comments object.
	 */
	public Comments buildComments(String comments) {
		return new Comments(comments);
	}

	/**
	 * 
	 * @param copyright
	 *            the copyright.
	 * @return an immutable Copyright object.
	 */
	public Copyright buildCopyright(String copyright) {
		return new Copyright(copyright);
	}

	/**
	 * 
	 * @param description
	 *            the description.
	 * @return an immutable Description object.
	 */
	public Description buildDescription(String description) {
		return new Description(description);
	}

	/**
	 * 
	 * @param docs
	 *            the documentation information.
	 * @return an immutable Docs object.
	 */
	public Docs buildDocs(String docs) {
		return new Docs(docs);
	}

	/**
	 * 
	 * @param attributes
	 *            should contain url, length and type
	 * @return an immutable Enclosure object.
	 * @throws RSSpectException
	 *             if the format of the data is not valid.
	 */
	public Enclosure buildEnclosure(List<Attribute> attributes)
			throws RSSpectException {
		return new Enclosure(attributes);
	}

	/**
	 * 
	 * @param elementName
	 *            the name of the extension element.
	 * @param attributes
	 *            additional attributes.
	 * @param content
	 *            the content of the extension element.
	 * @return an immutable Extension object.
	 * @throws RSSpectException
	 *             if the format of the data is not valid.
	 */
	public Extension buildExtension(String elementName,
			List<Attribute> attributes, String content) throws RSSpectException {
		return new Extension(elementName, attributes, content);
	}

	/**
	 * @param text
	 *            the text content.
	 * @return an immutable Generator object.
	 */
	public Generator buildGenerator(String text) {
		return new Generator(text);
	}

	/**
	 * 
	 * @param isPermaLink
	 *            the isPermaLink attributes.
	 * @param guid
	 *            the guid data.
	 * @return an immutable GUID object.
	 */
	public GUID buildGUID(Attribute isPermaLink, String guid) {
		return new GUID(isPermaLink, guid);
	}

	/**
	 * 
	 * @param height
	 *            should be a number 400 or less
	 * @return an immutable Height object.
	 * @throws RSSpectException
	 *             if the format of the data is not valid.
	 */
	public Height buildHeight(String height) throws RSSpectException {
		return new Height(height);
	}

	/**
	 * 
	 * @param url
	 *            the url element.
	 * @param title
	 *            the title element.
	 * @param link
	 *            the link element.
	 * @param width
	 *            the width element.
	 * @param height
	 *            the height element.
	 * @param description
	 *            the description element.
	 * @return an immutable Image object.
	 * @throws RSSpectException
	 *             if the format of the data is not valid.
	 */
	public Image buildImage(URL url, Title title, Link link, Width width,
			Height height, Description description) throws RSSpectException {
		return new Image(url, title, link, width, height, description);
	}

	/**
	 * 
	 * @param title
	 *            the title element.
	 * @param link
	 *            the link element.
	 * @param description
	 *            the description element.
	 * @param author
	 *            the author element.
	 * @param categories
	 *            the list of categories.
	 * @param comments
	 *            the comments element.
	 * @param enclosure
	 *            the enclosure element.
	 * @param guid
	 *            the guid element.
	 * @param pubDate
	 *            the published date element.
	 * @param source
	 *            the source element.
	 * @param extensions
	 *            the list of extensions.
	 * @return an immutable Item object.
	 * @throws RSSpectException
	 *             if the format of the data is not valid.
	 */
	public Item buildItem(Title title, Link link, Description description,
			Author author, List<Category> categories, Comments comments,
			Enclosure enclosure, GUID guid, PubDate pubDate, Source source,
			List<Extension> extensions) throws RSSpectException {
		return new Item(title, link, description, author, categories, comments,
				enclosure, guid, pubDate, source, extensions);
	}

	/**
	 * 
	 * @param language
	 *            the language.
	 * @return an immutable Language object.
	 */
	public Language buildLanguage(String language) {
		return new Language(language);
	}

	/**
	 * 
	 * @param lastBuildDate
	 *            the last build date.
	 * @return an immutable LastBuildDate object.
	 * @throws RSSpectException
	 *             if the format of the data is not valid.
	 */
	public LastBuildDate buildLastBuildDate(String lastBuildDate)
			throws RSSpectException {
		return new LastBuildDate(lastBuildDate);
	}

	/**
	 * 
	 * @param link
	 *            the link information.
	 * @return an immutable Link object.
	 * @throws RSSpectException
	 *             if the format of the data is not valid.
	 */
	public Link buildLink(String link) throws RSSpectException {
		return new Link(link);
	}

	/**
	 * 
	 * @param managingEditor
	 *            the managing editor.
	 * @return an immutable ManagingEditor object.
	 */
	public ManagingEditor buildManagingEditor(String managingEditor) {
		return new ManagingEditor(managingEditor);
	}

	/**
	 * 
	 * @param name
	 *            the name.
	 * @return an immutable Name object.
	 */
	public Name buildName(String name) {
		return new Name(name);
	}

	/**
	 * 
	 * @param pubDate
	 *            the published date.
	 * @return an immutable PubDate object.
	 * @throws RSSpectException
	 *             If the dateTime format is invalid.
	 */
	public PubDate buildPubDate(String pubDate) throws RSSpectException {
		return new PubDate(pubDate);
	}

	/**
	 * 
	 * @param rating
	 *            the rating information.
	 * @return an immutable Rating object.
	 */
	public Rating buildRating(String rating) {
		return new Rating(rating);
	}

	/**
	 * 
	 * @param skipDays
	 *            the days to skip.
	 * @throws RSSpectException
	 *             if the format of the data is not valid.
	 * @return an immutable SkipDays object.
	 */
	public SkipDays buildSkipDays(List<Day> skipDays) throws RSSpectException {
		return new SkipDays(skipDays);
	}

	/**
	 * 
	 * @param skipHours
	 *            the hours to skip.
	 * @throws RSSpectException
	 *             if the format of the data is not valid.
	 * @return an immutable SkipHours object.
	 */
	public SkipHours buildSkipHours(List<Hour> skipHours)
			throws RSSpectException {
		return new SkipHours(skipHours);
	}

	/**
	 * @param day
	 *            the day of the week.
	 * @return a Day object.
	 * @throws RSSpectException
	 *             if the format of the data is not valid.
	 */
	public Day buildDay(String day) throws RSSpectException {
		return new Day(day);
	}

	/**
	 * @param hour
	 *            the hour of the day.
	 * @return an Hour object.
	 * @throws RSSpectException
	 *             if the format of the data is not valid.
	 */
	public Hour buildHour(String hour) throws RSSpectException {
		return new Hour(hour);
	}

	/**
	 * 
	 * @param url
	 *            the url attribute.
	 * @param source
	 *            the source information.
	 * @return an immutable Source object.
	 * @throws RSSpectException
	 *             if the format of the data is not valid.
	 */
	public Source buildSource(Attribute url, String source)
			throws RSSpectException {
		return new Source(url, source);
	}

	/**
	 * 
	 * @param title
	 *            the title element.
	 * @param description
	 *            the description element.
	 * @param name
	 *            the name element.
	 * @param link
	 *            the link element.
	 * @return an immutable TextInput object.
	 * @throws RSSpectException
	 *             if the format of the data is not valid.
	 */
	public TextInput buildTextInput(Title title, Description description,
			Name name, Link link) throws RSSpectException {
		return new TextInput(title, description, name, link);
	}

	/**
	 * 
	 * @param title
	 *            the title.
	 * @return an immutable Title object.
	 */
	public Title buildTitle(String title) {
		return new Title(title);
	}

	/**
	 * 
	 * @param ttl
	 *            the time to live.
	 * @return an immutable TTL object.
	 */
	public TTL buildTTL(String ttl) {
		return new TTL(ttl);
	}

	/**
	 * 
	 * @param url
	 *            the url.
	 * @return an immutable URL object.
	 * @throws RSSpectException
	 *             if the format of the data is not valid.
	 */
	public URL buildURL(String url) throws RSSpectException {
		return new URL(url);
	}

	/**
	 * 
	 * @param webMaster
	 *            the web master.
	 * @return an immutable WebMaster object.
	 */
	public WebMaster buildWebMaster(String webMaster) {
		return new WebMaster(webMaster);
	}

	/**
	 * 
	 * @param width
	 *            the width.
	 * @return an immutable Width object.
	 * @throws RSSpectException
	 *             if the format of the data is not valid.
	 */
	public Width buildWidth(String width) throws RSSpectException {
		return new Width(width);
	}

	// used to write feed output for several feed writing methods.
	private void writeRSSOutput(RSS rss, XMLStreamWriter writer,
			String encoding, String version) throws Exception {

		if (rss == null) {
			throw new RSSpectException("The rss feed object cannot be null.");
		}

		Channel channel = rss.getChannel();

		rss = buildRSS(buildChannel(channel.getTitle(), channel.getLink(),
				channel.getDescription(), channel.getLanguage(), channel
						.getCopyright(), channel.getManagingEditor(), channel
						.getWebMaster(), channel.getPubDate(), channel
						.getLastBuildDate(), channel.getCategories(),
				getRSSpectVersion(), channel.getDocs(), channel.getCloud(),
				channel.getTtl(), channel.getImage(), channel.getRating(),
				channel.getTextInput(), channel.getSkipHours(), channel
						.getSkipDays(), channel.getExtensions(), channel
						.getItems()), rss.getAttributes(), rss.getExtensions());

		// write the xml header.
		writer.writeStartDocument(encoding, version);
		new RSSWriter().writeRSS(writer, rss);
		writer.flush();
		writer.close();
	}

	/**
	 * @return the xml encoding of the document eg. UTF-8
	 */
	public String getEncoding() {
		return encoding;
	}

	/**
	 * @return the xml document version of the document eg. 1.0
	 */
	public String getXmlVersion() {
		return xmlVersion;
	}

	/**
	 * @return the atomsphere library version.
	 */
	public String getLibVersion() {
		return libVersion;
	}
}
